# 私有 AI 对话网站 — 技术方案

> 版本：v1.1 | 日期：2026-02-21
>
> 变更记录：v1.1 — 调整为 Supabase 云服务方案（托管 PostgreSQL + Auth），适配小规模云服务器部署场景

---

## 目录

1. [项目概述](#1-项目概述)
2. [推荐技术栈](#2-推荐技术栈)
3. [系统架构](#3-系统架构)
4. [数据库设计](#4-数据库设计)
5. [API 端点设计](#5-api-端点设计)
6. [认证与白名单机制](#6-认证与白名单机制)
7. [AI 对话流式代理](#7-ai-对话流式代理)
8. [管理后台功能](#8-管理后台功能)
9. [安全考量](#9-安全考量)
10. [项目目录结构](#10-项目目录结构)
11. [环境变量配置](#11-环境变量配置)
12. [部署方案](#12-部署方案)
13. [开发阶段与里程碑](#13-开发阶段与里程碑)
14. [技术决策备忘](#14-技术决策备忘)
15. [关键风险与应对](#15-关键风险与应对)

---

## 1. 项目概述

### 1.1 项目目标

搭建一个**小规模、受控访问**的 AI 对话网站，部署在云服务器上，对接已有的 Anthropic 格式 API（`/v1/messages`），为白名单用户提供安全、可审计的 AI 对话服务。

### 1.2 规模定位

- **用户量**：数十人级别，白名单控制
- **部署方式**：云服务器（如阿里云 / 腾讯云 / AWS 等）
- **运维目标**：尽量少的自托管组件，降低运维负担

### 1.3 三大核心需求

| 需求 | 描述 |
|------|------|
| **AI 对话功能** | 支持多轮对话、流式输出（SSE）、会话管理（新建/历史/删除）、Markdown 渲染 |
| **白名单注册机制** | 仅白名单中的邮箱可注册；管理员预先添加白名单条目；注册后自动关联 |
| **管理后台** | 用户管理、白名单管理、用量统计（token 消耗）、聊天记录审计、系统仪表盘 |

---

## 2. 推荐技术栈

| 层级 | 技术选型 | 说明 |
|------|---------|------|
| **框架** | Next.js 15 (App Router) | 全栈方案，前后端统一，支持 Server Actions、Route Handlers、Middleware |
| **语言** | TypeScript 5 | 全栈类型安全 |
| **后端服务** | Supabase（云版） | 提供托管 PostgreSQL + 认证服务 + 实时订阅，免数据库运维 |
| **ORM** | Prisma 6 | 连接 Supabase 的 PostgreSQL，提供类型安全的数据库访问和迁移管理 |
| **认证** | Supabase Auth | 内置邮箱密码注册/登录，支持 OAuth，与 Supabase 数据库深度集成 |
| **UI 框架** | Tailwind CSS 4 + shadcn/ui | 快速构建现代化 UI，组件可定制性强 |
| **状态管理** | Zustand | 轻量级，适合管理对话列表、当前会话等前端状态 |
| **Markdown 渲染** | react-markdown + remark-gfm + rehype-highlight | AI 输出渲染，支持代码高亮 |
| **部署** | Docker + Nginx（仅应用层） | 容器化部署 Next.js 应用，数据库由 Supabase 云托管 |
| **包管理** | pnpm | 快速、节省磁盘空间 |

### 2.1 Supabase 在本项目中的角色

```
Supabase 提供的服务        本项目使用情况
─────────────────────    ──────────────
PostgreSQL 数据库    ──→  ✅ 核心数据存储（通过 Prisma 连接）
Auth 认证服务        ──→  ✅ 用户注册/登录/Session 管理
Realtime 实时订阅    ──→  ❌ 不使用（SSE 由自建代理处理）
Storage 文件存储     ──→  ❌ 不使用
Edge Functions       ──→  ❌ 不使用（逻辑在 Next.js Route Handler 中）
```

> Supabase 免费套餐包含 500MB 数据库、50,000 月活用户认证、无限 API 请求，对小规模应用足够。超出后 Pro 套餐 $25/月。

---

## 3. 系统架构

### 3.1 架构总览

```
┌─────────────────────────────────────────────────────────────────┐
│                         客户端（浏览器）                          │
│  ┌──────────┐  ┌──────────────┐  ┌───────────────┐              │
│  │  对话页面  │  │  管理后台页面  │  │  登录/注册页面  │             │
│  └────┬─────┘  └──────┬───────┘  └───────┬───────┘              │
└───────┼───────────────┼──────────────────┼──────────────────────┘
        │               │                  │
        ▼               ▼                  ▼
┌─────────────────────────────────────────────────────────────────┐
│              云服务器（Docker 容器）                               │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                  Next.js 15 (App Router)                  │   │
│  │                                                           │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌────────────────┐  │   │
│  │  │  Middleware   │  │  Supabase    │  │ Route Handlers │  │   │
│  │  │  (路由保护)   │  │  Auth Client │  │ /api/chat      │  │   │
│  │  │              │  │              │  │ /api/admin/*   │  │   │
│  │  └──────────────┘  └──────────────┘  └───────┬────────┘  │   │
│  │                                               │           │   │
│  │  ┌────────────────────────────────────────────┤           │   │
│  │  │  Prisma ORM                                │           │   │
│  │  └──────────┬─────────────────────────────────┘           │   │
│  └─────────────┼─────────────────────────────────────────────┘   │
└────────────────┼──────────────────────┬──────────────────────────┘
                 │                      │
                 ▼                      ▼
  ┌──────────────────────────┐  ┌───────────────────┐
  │  Supabase Cloud          │  │  AI API 服务       │
  │  ┌────────────────────┐  │  │  /v1/messages      │
  │  │ PostgreSQL (托管)   │  │  │  (Anthropic 格式)  │
  │  ├────────────────────┤  │  └───────────────────┘
  │  │ Auth Service (托管) │  │
  │  └────────────────────┘  │
  └──────────────────────────┘
```

### 3.2 组件职责分工

| 组件 | 部署位置 | 职责 |
|------|---------|------|
| Next.js 应用 | 云服务器 (Docker) | 前端渲染、API 路由、SSE 代理、业务逻辑 |
| Nginx | 云服务器 (Docker) | 反向代理、HTTPS 终止、SSE 透传 |
| Supabase Auth | Supabase 云 | 用户注册/登录、Session/JWT 管理 |
| PostgreSQL | Supabase 云 | 数据持久化（会话、消息、用量等） |
| AI API | 第三方 | Anthropic 格式的 LLM 推理服务 |

### 3.3 请求流（对话场景）

```
用户输入 → 浏览器 fetch(/api/chat, stream)
         → Middleware 校验 Supabase session
         → Route Handler 验证参数 & 记录请求
         → 转发至 AI API /v1/messages (stream: true)
         → SSE 逐块返回（解析 Anthropic 事件类型）
         → 前端逐字渲染
         → 流结束 → 提取 token 用量 → 通过 Prisma 写入 Supabase DB
```

---

## 4. 数据库设计

### 4.1 数据库架构说明

数据库使用 **Supabase 托管的 PostgreSQL**，通过 **Prisma ORM** 进行访问和迁移管理。

用户认证数据由 Supabase Auth 管理（存储在 `auth.users` 内部表），业务数据存储在 `public` schema 下的自定义表中。两者通过 `auth.users.id` 关联。

```
Supabase Auth 管理          Prisma 管理（public schema）
─────────────────          ────────────────────────────
auth.users (内部)  ──1:1──→ profiles（用户业务信息）
                              │
                              ├── 1:N ──→ conversations ──→ 1:N ──→ messages
                              │
                              └── 1:N ──→ api_usage_logs

                           whitelist（独立，通过 email 关联）
                           admin_audit_logs（独立审计表）
```

### 4.2 Prisma Schema

```prisma
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")       // Supabase 连接串（Transaction mode）
  directUrl = env("DIRECT_URL")         // Supabase 直连串（用于 Prisma migrate）
}

// ============ 用户资料表 ============
// 与 Supabase Auth 的 auth.users 通过 id 一一对应
// 注册时由触发器或注册回调自动创建
model Profile {
  id          String     @id                        // 等于 auth.users.id（UUID）
  email       String     @unique
  name        String?
  role        Role       @default(USER)
  status      UserStatus @default(ACTIVE)
  createdAt   DateTime   @default(now()) @map("created_at")
  updatedAt   DateTime   @updatedAt @map("updated_at")
  lastLoginAt DateTime?  @map("last_login_at")

  conversations Conversation[]
  usageLogs     ApiUsageLog[]

  @@map("profiles")
}

enum Role {
  USER
  ADMIN
}

enum UserStatus {
  ACTIVE
  DISABLED
}

// ============ 白名单表 ============
model Whitelist {
  id        String   @id @default(cuid())
  email     String   @unique
  note      String?              // 管理员备注，如 "张三 - 研发部"
  used      Boolean  @default(false)  // 是否已被注册使用
  createdAt DateTime @default(now()) @map("created_at")
  createdBy String   @map("created_by")  // 添加该条目的管理员 ID

  @@map("whitelist")
}

// ============ 会话表 ============
model Conversation {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  title     String   @default("新对话")
  model     String   @default("claude-sonnet-4-20250514")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user     Profile   @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages Message[]

  @@index([userId, updatedAt(sort: Desc)])
  @@map("conversations")
}

// ============ 消息表 ============
model Message {
  id             String   @id @default(cuid())
  conversationId String   @map("conversation_id")
  role           MessageRole
  content        String           // 消息文本内容
  createdAt      DateTime @default(now()) @map("created_at")

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
  @@map("messages")
}

enum MessageRole {
  user
  assistant
}

// ============ API 用量日志表 ============
model ApiUsageLog {
  id             String   @id @default(cuid())
  userId         String   @map("user_id")
  conversationId String?  @map("conversation_id")
  model          String
  inputTokens    Int      @map("input_tokens")
  outputTokens   Int      @map("output_tokens")
  totalTokens    Int      @map("total_tokens")
  durationMs     Int?     @map("duration_ms")    // 请求耗时（毫秒）
  createdAt      DateTime @default(now()) @map("created_at")

  user Profile @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([createdAt])
  @@map("api_usage_logs")
}

// ============ 管理员审计日志表 ============
model AdminAuditLog {
  id        String   @id @default(cuid())
  adminId   String   @map("admin_id")    // 操作管理员 ID
  action    String                        // 操作类型，如 "DISABLE_USER", "ADD_WHITELIST"
  target    String?                       // 操作对象，如用户 ID 或邮箱
  detail    Json?                         // 操作详情（JSON 格式）
  createdAt DateTime @default(now()) @map("created_at")

  @@index([adminId, createdAt])
  @@index([createdAt])
  @@map("admin_audit_logs")
}
```

### 4.3 与 Supabase Auth 的关联

注册成功后，需要在 `profiles` 表创建对应记录。两种实现方式：

**方式 A：数据库触发器（推荐）**

在 Supabase SQL Editor 中创建触发器，用户在 `auth.users` 注册后自动创建 `profiles` 行：

```sql
-- 在 Supabase SQL Editor 中执行
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.profiles (id, email, role, status, created_at, updated_at)
  VALUES (
    NEW.id,
    NEW.email,
    'USER',
    'ACTIVE',
    NOW(),
    NOW()
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
```

**方式 B：注册 API 中手动创建**

在 `/api/auth/register` 的 Route Handler 中，Supabase Auth 注册成功后，用 Prisma 创建 `profiles` 记录。

### 4.4 核心表字段说明

#### profiles（用户资料表）

| 字段 | 类型 | 说明 |
|------|------|------|
| id | String (UUID) | 主键，与 `auth.users.id` 一致 |
| email | String | 唯一，登录标识 |
| name | String? | 显示名称 |
| role | Enum | USER / ADMIN |
| status | Enum | ACTIVE / DISABLED |
| lastLoginAt | DateTime? | 最近登录时间 |

> 注意：密码由 Supabase Auth 管理，不在 `profiles` 表中存储。

#### whitelist（白名单表）

| 字段 | 类型 | 说明 |
|------|------|------|
| id | String (CUID) | 主键 |
| email | String | 唯一，允许注册的邮箱 |
| note | String? | 管理员备注 |
| used | Boolean | 是否已被注册消费 |
| createdBy | String | 添加该条目的管理员 ID |

#### conversations（会话表）

| 字段 | 类型 | 说明 |
|------|------|------|
| id | String (CUID) | 主键 |
| userId | String | 外键 → profiles.id |
| title | String | 会话标题，默认"新对话"，可由首条消息自动生成 |
| model | String | 使用的模型标识 |

#### messages（消息表）

| 字段 | 类型 | 说明 |
|------|------|------|
| id | String (CUID) | 主键 |
| conversationId | String | 外键 → conversations.id |
| role | Enum | user / assistant |
| content | String | 消息文本（支持 Markdown） |

#### api_usage_logs（API 用量日志表）

| 字段 | 类型 | 说明 |
|------|------|------|
| id | String (CUID) | 主键 |
| userId | String | 外键 → profiles.id |
| conversationId | String? | 关联会话（可选） |
| model | String | 模型标识 |
| inputTokens | Int | 输入 token 数 |
| outputTokens | Int | 输出 token 数 |
| totalTokens | Int | 总 token 数 |
| durationMs | Int? | 请求耗时 |

#### admin_audit_logs（管理员审计日志表）

| 字段 | 类型 | 说明 |
|------|------|------|
| id | String (CUID) | 主键 |
| adminId | String | 操作管理员 ID |
| action | String | 操作类型枚举值 |
| target | String? | 操作对象标识 |
| detail | Json? | 操作详情 |

---

## 5. API 端点设计

### 5.1 认证相关

| 方法 | 路径 | 说明 | 认证 |
|------|------|------|------|
| POST | `/api/auth/register` | 注册（白名单校验 → Supabase Auth 注册） | 无 |
| POST | `/api/auth/login` | 登录（调用 Supabase Auth） | 无 |
| POST | `/api/auth/logout` | 登出 | 需登录 |
| GET | `/api/auth/session` | 获取当前会话信息 | 需登录 |
| POST | `/api/auth/callback` | Supabase Auth 回调处理 | 无 |

### 5.2 对话相关

| 方法 | 路径 | 说明 | 认证 |
|------|------|------|------|
| POST | `/api/chat` | 发送消息，流式返回 AI 响应（SSE） | 需登录 |
| GET | `/api/conversations` | 获取当前用户的会话列表 | 需登录 |
| POST | `/api/conversations` | 创建新会话 | 需登录 |
| GET | `/api/conversations/[id]` | 获取指定会话的消息历史 | 需登录（仅本人） |
| PATCH | `/api/conversations/[id]` | 更新会话标题 | 需登录（仅本人） |
| DELETE | `/api/conversations/[id]` | 删除会话 | 需登录（仅本人） |

### 5.3 管理后台

| 方法 | 路径 | 说明 | 认证 |
|------|------|------|------|
| GET | `/api/admin/dashboard` | 仪表盘统计数据 | ADMIN |
| GET | `/api/admin/users` | 用户列表（支持分页/搜索） | ADMIN |
| PATCH | `/api/admin/users/[id]` | 修改用户状态/角色 | ADMIN |
| GET | `/api/admin/whitelist` | 白名单列表 | ADMIN |
| POST | `/api/admin/whitelist` | 添加白名单条目（支持批量） | ADMIN |
| DELETE | `/api/admin/whitelist/[id]` | 删除白名单条目 | ADMIN |
| GET | `/api/admin/usage` | 用量统计（支持按用户/日期筛选） | ADMIN |
| GET | `/api/admin/conversations` | 查看所有用户聊天记录 | ADMIN |
| GET | `/api/admin/conversations/[id]` | 查看指定会话详情 | ADMIN |
| GET | `/api/admin/audit-logs` | 管理员操作审计日志 | ADMIN |

---

## 6. 认证与白名单机制

### 6.1 注册流程

```
用户访问注册页面
       │
       ▼
输入邮箱 + 密码 + 姓名
       │
       ▼
POST /api/auth/register
       │
       ▼
┌──────────────────────────┐
│ 1. 查询 whitelist 表      │
│    WHERE email = ?        │
│    AND used = false       │
└──────────┬───────────────┘
           │
     ┌─────┴─────┐
     │  是否存在？ │
     └─────┬─────┘
      No   │   Yes
      │    │
      ▼    ▼
    拒绝  2. 调用 Supabase Auth signUp()
    注册      │
              ▼
          3. 触发器自动创建 profiles 行
              │
              ▼
          4. 更新 whitelist.used = true
              │
              ▼
          5. 更新 profiles.name
              │
              ▼
          返回成功，引导登录
```

### 6.2 Supabase 客户端配置

```typescript
// lib/supabase/server.ts
// 服务端 Supabase 客户端（用于 Route Handlers 和 Server Components）

import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createClient() {
  const cookieStore = await cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) =>
            cookieStore.set(name, value, options)
          );
        },
      },
    }
  );
}
```

```typescript
// lib/supabase/client.ts
// 浏览器端 Supabase 客户端

import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
```

### 6.3 注册 API 实现

```typescript
// app/api/auth/register/route.ts

import { createClient } from "@/lib/supabase/server";
import { prisma } from "@/lib/prisma";
import { NextRequest, NextResponse } from "next/server";

export async function POST(req: NextRequest) {
  const { email, password, name } = await req.json();

  // 1. 白名单校验
  const whitelistEntry = await prisma.whitelist.findFirst({
    where: { email, used: false },
  });

  if (!whitelistEntry) {
    return NextResponse.json(
      { error: "该邮箱不在白名单中或已被使用" },
      { status: 403 }
    );
  }

  // 2. 调用 Supabase Auth 注册
  const supabase = await createClient();
  const { data, error } = await supabase.auth.signUp({
    email,
    password,
  });

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }

  // 3. 更新白名单状态 + 用户姓名
  await Promise.all([
    prisma.whitelist.update({
      where: { id: whitelistEntry.id },
      data: { used: true },
    }),
    // profiles 由触发器创建，这里更新 name
    prisma.profile.update({
      where: { id: data.user!.id },
      data: { name },
    }),
  ]);

  return NextResponse.json({ message: "注册成功" });
}
```

### 6.4 Middleware 路由保护

```typescript
// middleware.ts

import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";
import { prisma } from "@/lib/prisma";

export async function middleware(req: NextRequest) {
  const { pathname } = req.nextUrl;
  let response = NextResponse.next({ request: req });

  // 创建 Supabase 客户端（在 middleware 中需手动处理 cookie）
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return req.cookies.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => {
            req.cookies.set(name, value);
            response.cookies.set(name, value, options);
          });
        },
      },
    }
  );

  // 刷新 session（重要：防止过期）
  const { data: { user } } = await supabase.auth.getUser();

  // 公开路由
  const publicPaths = ["/login", "/register"];
  if (publicPaths.some((p) => pathname.startsWith(p))) {
    if (user) {
      return NextResponse.redirect(new URL("/", req.url));
    }
    return response;
  }

  // 未登录 → 跳转登录
  if (!user) {
    return NextResponse.redirect(new URL("/login", req.url));
  }

  // 管理后台路由保护
  // 注意：此处查询 profiles 表获取 role
  // 为减少数据库查询，可将 role 写入 JWT 的 app_metadata
  if (pathname.startsWith("/admin") || pathname.startsWith("/api/admin")) {
    // 从 Supabase JWT 的 app_metadata 中读取角色（见 6.5）
    const role = user.app_metadata?.role;
    if (role !== "ADMIN") {
      return pathname.startsWith("/api")
        ? NextResponse.json({ error: "Forbidden" }, { status: 403 })
        : NextResponse.redirect(new URL("/", req.url));
    }
  }

  return response;
}

export const config = {
  matcher: ["/((?!_next/static|_next/image|favicon.ico|api/auth/callback).*)"],
};
```

### 6.5 将角色写入 Supabase JWT

为避免每次请求都查 `profiles` 表获取角色，通过 Supabase 的数据库函数将 `role` 注入 JWT 的 `app_metadata`：

```sql
-- 在 Supabase SQL Editor 中执行
-- 创建函数：同步 profiles.role 到 auth.users.raw_app_meta_data
CREATE OR REPLACE FUNCTION public.sync_role_to_auth()
RETURNS trigger AS $$
BEGIN
  UPDATE auth.users
  SET raw_app_meta_data = raw_app_meta_data || jsonb_build_object('role', NEW.role::text)
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 当 profiles.role 变更时自动同步
CREATE TRIGGER on_profile_role_change
  AFTER INSERT OR UPDATE OF role ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION public.sync_role_to_auth();
```

同时在 Supabase Dashboard → Authentication → JWT 配置中，确保 `app_metadata` 包含在 JWT claims 中（默认包含）。

### 6.6 创建初始管理员

```typescript
// prisma/seed.ts

import { createClient } from "@supabase/supabase-js";
import { PrismaClient } from "@prisma/client";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!  // 注意：使用 service_role key
);
const prisma = new PrismaClient();

async function main() {
  const adminEmail = process.env.ADMIN_EMAIL!;
  const adminPassword = process.env.ADMIN_PASSWORD!;

  // 1. 在 Supabase Auth 中创建管理员用户
  const { data, error } = await supabase.auth.admin.createUser({
    email: adminEmail,
    password: adminPassword,
    email_confirm: true,  // 跳过邮箱验证
    app_metadata: { role: "ADMIN" },
  });

  if (error) throw error;

  // 2. 更新 profiles 表中的角色（触发器已自动创建 profiles 行）
  await prisma.profile.update({
    where: { id: data.user.id },
    data: { role: "ADMIN", name: "管理员" },
  });

  // 3. 添加管理员到白名单（标记为已使用）
  await prisma.whitelist.create({
    data: {
      email: adminEmail,
      note: "系统初始管理员",
      used: true,
      createdBy: data.user.id,
    },
  });

  console.log("初始管理员创建成功:", adminEmail);
}

main()
  .catch(console.error)
  .finally(() => prisma.$disconnect());
```

---

## 7. AI 对话流式代理

### 7.1 核心实现：`/api/chat` Route Handler

此处是整个系统的关键路径——将用户请求转发至 AI API，以 SSE 方式流式返回，同时提取 token 用量。

**Anthropic SSE 事件类型说明：**

| 事件类型 | 说明 | 包含数据 |
|----------|------|----------|
| `message_start` | 消息开始 | `message` 对象（含 `usage.input_tokens`） |
| `content_block_start` | 内容块开始 | `content_block` 对象 |
| `content_block_delta` | 内容增量 | `delta.text`（实际文本片段） |
| `content_block_stop` | 内容块结束 | 无 |
| `message_delta` | 消息级增量 | `usage.output_tokens` |
| `message_stop` | 消息结束 | 无 |
| `ping` | 心跳 | 无 |
| `error` | 错误 | 错误详情 |

```typescript
// app/api/chat/route.ts

import { createClient } from "@/lib/supabase/server";
import { prisma } from "@/lib/prisma";
import { NextRequest } from "next/server";

const AI_API_BASE = process.env.AI_API_BASE_URL!;
const AI_API_KEY = process.env.AI_API_KEY!;

export async function POST(req: NextRequest) {
  // 1. 认证校验（通过 Supabase Auth）
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    return new Response(JSON.stringify({ error: "Unauthorized" }), {
      status: 401,
    });
  }

  // 检查用户状态
  const profile = await prisma.profile.findUnique({
    where: { id: user.id },
  });
  if (!profile || profile.status === "DISABLED") {
    return new Response(JSON.stringify({ error: "Account disabled" }), {
      status: 403,
    });
  }

  const userId = user.id;

  // 2. 解析请求体
  const { conversationId, message, model = "claude-sonnet-4-20250514" } = await req.json();

  if (!conversationId || !message?.trim()) {
    return new Response(JSON.stringify({ error: "Invalid request" }), {
      status: 400,
    });
  }

  // 3. 验证会话归属
  const conversation = await prisma.conversation.findFirst({
    where: { id: conversationId, userId },
    include: {
      messages: {
        orderBy: { createdAt: "asc" },
        select: { role: true, content: true },
      },
    },
  });

  if (!conversation) {
    return new Response(JSON.stringify({ error: "Conversation not found" }), {
      status: 404,
    });
  }

  // 4. 保存用户消息到数据库
  await prisma.message.create({
    data: {
      conversationId,
      role: "user",
      content: message,
    },
  });

  // 5. 构建 Anthropic 格式的消息列表
  const messages = [
    ...conversation.messages.map((m) => ({
      role: m.role,
      content: m.content,
    })),
    { role: "user", content: message },
  ];

  // 6. 调用 AI API（流式）
  const startTime = Date.now();

  const aiResponse = await fetch(`${AI_API_BASE}/v1/messages`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-api-key": AI_API_KEY,
      "anthropic-version": "2023-06-01",
    },
    body: JSON.stringify({
      model,
      max_tokens: 4096,
      messages,
      stream: true,
    }),
  });

  if (!aiResponse.ok || !aiResponse.body) {
    const errText = await aiResponse.text();
    console.error("AI API error:", aiResponse.status, errText);
    return new Response(
      JSON.stringify({ error: "AI service unavailable" }),
      { status: 502 }
    );
  }

  // 7. 创建 TransformStream 处理 SSE
  let inputTokens = 0;
  let outputTokens = 0;
  let assistantContent = "";

  const decoder = new TextDecoder();

  const transformStream = new TransformStream({
    async transform(chunk, controller) {
      const text = decoder.decode(chunk, { stream: true });
      // 将原始 SSE 数据转发给客户端
      controller.enqueue(chunk);

      // 解析 SSE 事件提取数据
      const lines = text.split("\n");
      for (const line of lines) {
        if (!line.startsWith("data: ")) continue;
        const dataStr = line.slice(6).trim();
        if (dataStr === "[DONE]") continue;

        try {
          const data = JSON.parse(dataStr);

          switch (data.type) {
            case "message_start":
              // 从 message_start 提取 input_tokens
              inputTokens = data.message?.usage?.input_tokens ?? 0;
              break;

            case "content_block_delta":
              // 累积助手回复文本
              if (data.delta?.text) {
                assistantContent += data.delta.text;
              }
              break;

            case "message_delta":
              // 从 message_delta 提取 output_tokens
              outputTokens = data.usage?.output_tokens ?? 0;
              break;

            case "error":
              console.error("AI stream error:", data.error);
              break;
          }
        } catch {
          // 非 JSON 行，忽略
        }
      }
    },

    async flush() {
      // 8. 流结束后：保存助手消息 + 记录用量
      const durationMs = Date.now() - startTime;

      await Promise.all([
        prisma.message.create({
          data: {
            conversationId,
            role: "assistant",
            content: assistantContent,
          },
        }),
        prisma.apiUsageLog.create({
          data: {
            userId,
            conversationId,
            model,
            inputTokens,
            outputTokens,
            totalTokens: inputTokens + outputTokens,
            durationMs,
          },
        }),
        prisma.conversation.update({
          where: { id: conversationId },
          data: { updatedAt: new Date() },
        }),
      ]);
    },
  });

  // 9. 返回 SSE 流响应
  return new Response(aiResponse.body.pipeThrough(transformStream), {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive",
    },
  });
}
```

### 7.2 前端 SSE 消费

```typescript
// lib/chat-client.ts

export async function sendMessage(
  conversationId: string,
  message: string,
  onChunk: (text: string) => void,
  onDone: () => void,
  onError: (err: Error) => void
) {
  const res = await fetch("/api/chat", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ conversationId, message }),
  });

  if (!res.ok) {
    onError(new Error(`HTTP ${res.status}`));
    return;
  }

  const reader = res.body!.getReader();
  const decoder = new TextDecoder();

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    const text = decoder.decode(value, { stream: true });
    const lines = text.split("\n");

    for (const line of lines) {
      if (!line.startsWith("data: ")) continue;
      const dataStr = line.slice(6).trim();
      if (dataStr === "[DONE]") continue;

      try {
        const data = JSON.parse(dataStr);
        if (data.type === "content_block_delta" && data.delta?.text) {
          onChunk(data.delta.text);
        }
      } catch {
        // 忽略解析失败的行
      }
    }
  }

  onDone();
}
```

### 7.3 会话标题自动生成

首次收到助手回复后，可选地根据用户首条消息自动生成会话标题：

```typescript
// lib/title-generator.ts

export async function generateTitle(userMessage: string): Promise<string> {
  // 方案 A：截取用户消息前 30 字符
  const title = userMessage.slice(0, 30) + (userMessage.length > 30 ? "..." : "");
  return title;

  // 方案 B：调用 AI 生成标题（额外消耗 token，可选）
  // const res = await fetch(`${AI_API_BASE}/v1/messages`, { ... });
}
```

---

## 8. 管理后台功能

### 8.1 功能模块总览

```
/admin
  ├── /dashboard      仪表盘
  ├── /users          用户管理
  ├── /whitelist      白名单管理
  ├── /usage          用量统计
  ├── /conversations  聊天记录
  └── /audit-logs     审计日志
```

### 8.2 仪表盘 `/admin/dashboard`

展示系统整体运行状况的关键指标：

| 指标卡片 | 数据来源 |
|----------|---------|
| 总用户数 | `COUNT(profiles)` |
| 今日活跃用户 | `COUNT(DISTINCT api_usage_logs.user_id) WHERE created_at >= today` |
| 今日对话数 | `COUNT(conversations) WHERE created_at >= today` |
| 今日 Token 消耗 | `SUM(api_usage_logs.total_tokens) WHERE created_at >= today` |
| 本月 Token 消耗趋势图 | 按日聚合 `api_usage_logs` |
| 剩余白名单名额 | `COUNT(whitelist) WHERE used = false` |

### 8.3 用户管理 `/admin/users`

- **列表展示**：邮箱、姓名、角色、状态、注册时间、最近登录、累计 Token
- **操作**：
  - 启用/禁用用户（更新 `profiles.status`）
  - 修改角色（USER ↔ ADMIN，同步到 Supabase Auth `app_metadata`）
  - 查看用户的对话记录
- **搜索**：按邮箱/姓名搜索
- **分页**：服务端分页，每页 20 条

### 8.4 白名单管理 `/admin/whitelist`

- **列表展示**：邮箱、备注、添加时间、添加人、是否已注册
- **操作**：
  - 单条添加：输入邮箱 + 备注
  - 批量添加：支持 CSV 导入或文本框多行粘贴
  - 删除未使用的白名单条目
- **状态标记**：已注册（绿色）/ 未注册（灰色）

### 8.5 用量统计 `/admin/usage`

- **筛选维度**：时间范围、指定用户、指定模型
- **统计展示**：
  - Token 消耗趋势图（折线图，按日）
  - 用户 Token 排行榜（表格）
  - 模型使用分布（饼图）
  - 平均响应时间趋势

### 8.6 聊天记录查看 `/admin/conversations`

- **列表**：会话标题、用户、消息数、创建时间、最近更新
- **详情**：完整消息时间线（只读查看，不可编辑）
- **搜索**：按用户、内容关键词搜索

### 8.7 审计日志 `/admin/audit-logs`

记录所有管理操作（`admin_audit_logs` 表）：

| 操作类型 | 说明 |
|----------|------|
| `ADD_WHITELIST` | 添加白名单 |
| `DELETE_WHITELIST` | 删除白名单 |
| `DISABLE_USER` | 禁用用户 |
| `ENABLE_USER` | 启用用户 |
| `CHANGE_ROLE` | 修改用户角色 |

---

## 9. 安全考量

### 9.1 身份认证安全

| 措施 | 实现方式 |
|------|---------|
| 密码加密 | Supabase Auth 内置 bcrypt 加密 |
| JWT 签名 | Supabase Auth 内置，使用项目级 JWT Secret |
| 登录限流 | Supabase Auth 内置速率限制 |
| Session 刷新 | Supabase Auth 自动刷新 token，Middleware 中调用 `getUser()` 确保有效 |

### 9.2 API 安全

| 措施 | 实现方式 |
|------|---------|
| 请求限流 | 基于用户 ID 的令牌桶限流（如 10 req/min） |
| 输入校验 | 使用 Zod 对所有请求体进行 schema 校验 |
| CORS | Next.js 默认同源策略，按需配置 |
| 请求大小限制 | Next.js route config 中设置 `bodyParser.sizeLimit` |

### 9.3 API 密钥保护

| 措施 | 说明 |
|------|------|
| 服务端存储 | AI API Key 仅在服务端环境变量中，**绝不**暴露到前端 |
| 代理模式 | 前端 → `/api/chat` → AI API，前端不直接访问 AI API |
| Supabase Key 分级 | `anon key`（公开，前端用）仅有受限权限；`service_role key`（仅服务端）拥有完整权限 |
| 环境隔离 | 敏感 key 仅在服务端环境变量中，不以 `NEXT_PUBLIC_` 前缀暴露 |

### 9.4 数据安全

| 措施 | 说明 |
|------|------|
| 数据隔离 | 普通用户只能访问自己的会话（查询时 `WHERE userId = ?`） |
| 级联删除 | 删除会话时自动删除关联消息 |
| HTTPS | 生产环境强制 HTTPS（Nginx 配置） |
| 数据库备份 | Supabase Pro 套餐自动每日备份；免费套餐可手动 pg_dump |
| RLS（可选） | 可在 Supabase 开启 Row Level Security 作为额外保障 |

### 9.5 配额防护

| 措施 | 说明 |
|------|------|
| 每日 Token 上限 | 可按用户设置每日 Token 消耗上限 |
| 并发限制 | 单用户同一时间仅允许一个活跃的流式请求 |
| 消息长度限制 | 用户单条消息最大长度限制（如 10,000 字符） |
| 会话轮次限制 | 单个会话最大消息轮次（如 100 轮） |

---

## 10. 项目目录结构

```
ai-chat-site/
├── app/
│   ├── (auth)/                    # 认证相关页面（无布局嵌套）
│   │   ├── login/
│   │   │   └── page.tsx
│   │   ├── register/
│   │   │   └── page.tsx
│   │   └── auth/
│   │       └── callback/
│   │           └── route.ts       # Supabase Auth 回调
│   ├── (main)/                    # 主应用页面（共享侧边栏布局）
│   │   ├── layout.tsx             # 侧边栏 + 主内容区布局
│   │   ├── page.tsx               # 首页 → 重定向到新对话
│   │   └── chat/
│   │       └── [conversationId]/
│   │           └── page.tsx       # 对话页面
│   ├── admin/                     # 管理后台页面
│   │   ├── layout.tsx             # 管理后台布局（侧边导航）
│   │   ├── dashboard/
│   │   │   └── page.tsx
│   │   ├── users/
│   │   │   └── page.tsx
│   │   ├── whitelist/
│   │   │   └── page.tsx
│   │   ├── usage/
│   │   │   └── page.tsx
│   │   ├── conversations/
│   │   │   ├── page.tsx
│   │   │   └── [id]/
│   │   │       └── page.tsx
│   │   └── audit-logs/
│   │       └── page.tsx
│   ├── api/
│   │   ├── auth/
│   │   │   ├── register/
│   │   │   │   └── route.ts       # 白名单校验 + Supabase 注册
│   │   │   └── callback/
│   │   │       └── route.ts       # Supabase Auth 回调
│   │   ├── chat/
│   │   │   └── route.ts           # AI 对话流式代理（核心）
│   │   ├── conversations/
│   │   │   ├── route.ts            # GET(列表) / POST(创建)
│   │   │   └── [id]/
│   │   │       └── route.ts        # GET / PATCH / DELETE
│   │   └── admin/
│   │       ├── dashboard/
│   │       │   └── route.ts
│   │       ├── users/
│   │       │   ├── route.ts
│   │       │   └── [id]/
│   │       │       └── route.ts
│   │       ├── whitelist/
│   │       │   ├── route.ts
│   │       │   └── [id]/
│   │       │       └── route.ts
│   │       ├── usage/
│   │       │   └── route.ts
│   │       ├── conversations/
│   │       │   ├── route.ts
│   │       │   └── [id]/
│   │       │       └── route.ts
│   │       └── audit-logs/
│   │           └── route.ts
│   ├── layout.tsx                  # 根布局
│   └── globals.css
├── components/
│   ├── ui/                         # shadcn/ui 组件
│   │   ├── button.tsx
│   │   ├── input.tsx
│   │   ├── dialog.tsx
│   │   ├── table.tsx
│   │   ├── card.tsx
│   │   └── ...
│   ├── chat/
│   │   ├── chat-input.tsx          # 消息输入框
│   │   ├── chat-messages.tsx       # 消息列表
│   │   ├── message-bubble.tsx      # 单条消息气泡
│   │   ├── markdown-renderer.tsx   # Markdown 渲染组件
│   │   └── sidebar.tsx             # 会话列表侧边栏
│   └── admin/
│       ├── stats-card.tsx          # 统计卡片
│       ├── usage-chart.tsx         # 用量图表
│       └── data-table.tsx          # 通用数据表格
├── lib/
│   ├── supabase/
│   │   ├── server.ts               # 服务端 Supabase 客户端
│   │   └── client.ts               # 浏览器端 Supabase 客户端
│   ├── prisma.ts                   # Prisma Client 单例
│   ├── chat-client.ts              # 前端 SSE 客户端
│   ├── validators.ts               # Zod Schema 定义
│   └── utils.ts                    # 工具函数
├── stores/
│   └── chat-store.ts               # Zustand 对话状态管理
├── prisma/
│   ├── schema.prisma               # 数据库 Schema
│   ├── seed.ts                     # 初始数据种子（管理员账号）
│   └── migrations/                 # 迁移文件
├── public/
│   └── favicon.ico
├── middleware.ts                    # 全局路由保护（Supabase Auth）
├── next.config.ts
├── tailwind.config.ts
├── tsconfig.json
├── package.json
├── pnpm-lock.yaml
├── docker-compose.yml              # 仅 app + nginx（无数据库容器）
├── Dockerfile
├── nginx.conf
├── .env.example
└── .gitignore
```

---

## 11. 环境变量配置

`.env.example` 模板：

```bash
# ============ Supabase ============
NEXT_PUBLIC_SUPABASE_URL="https://your-project.supabase.co"     # Supabase 项目 URL
NEXT_PUBLIC_SUPABASE_ANON_KEY="eyJ..."                          # anon/public key（可暴露到前端）
SUPABASE_SERVICE_ROLE_KEY="eyJ..."                              # service_role key（仅服务端！）

# ============ 数据库（Supabase PostgreSQL）============
DATABASE_URL="postgresql://postgres.[ref]:[password]@aws-0-[region].pooler.supabase.com:6543/postgres?pgbouncer=true"   # Transaction mode（应用使用）
DIRECT_URL="postgresql://postgres.[ref]:[password]@aws-0-[region].pooler.supabase.com:5432/postgres"                     # Direct（Prisma migrate 使用）

# ============ AI API ============
AI_API_BASE_URL="https://your-api-host.com"         # AI API 基础地址（不含 /v1/messages）
AI_API_KEY="sk-ant-your-api-key"                     # API 密钥

# ============ 应用配置 ============
DEFAULT_MODEL="claude-sonnet-4-20250514"             # 默认模型
MAX_TOKENS_PER_REQUEST=4096                          # 单次请求最大 token
DAILY_TOKEN_LIMIT=100000                             # 每用户每日 token 上限（0 = 不限）
MAX_MESSAGE_LENGTH=10000                             # 单条消息最大字符数

# ============ 初始管理员（仅 seed 时使用）============
ADMIN_EMAIL="admin@example.com"
ADMIN_PASSWORD="change-me-on-first-login"
```

> **重要**：`SUPABASE_SERVICE_ROLE_KEY` 拥有绕过 RLS 的完整数据库权限，绝不能以 `NEXT_PUBLIC_` 前缀暴露到前端。

---

## 12. 部署方案

### 12.1 部署架构

由于数据库和认证服务由 Supabase 云托管，云服务器上只需部署 **Next.js 应用 + Nginx**，大幅简化运维。

```
云服务器
├── Docker
│   ├── app 容器（Next.js）      ← 唯一的应用容器
│   └── nginx 容器（反向代理）    ← HTTPS + SSE 透传
│
│   （无数据库容器！）
│
└── 连接外部服务
    ├── → Supabase Cloud（PostgreSQL + Auth）
    └── → AI API（Anthropic 格式）
```

### 12.2 Dockerfile

```dockerfile
# Dockerfile
FROM node:20-alpine AS base

RUN corepack enable && corepack prepare pnpm@latest --activate

# 依赖安装
FROM base AS deps
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN pnpm install --frozen-lockfile

# 构建
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

RUN pnpm prisma generate
RUN pnpm build

# 生产运行
FROM base AS runner
WORKDIR /app

ENV NODE_ENV=production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static
COPY --from=builder /app/prisma ./prisma

USER nextjs

EXPOSE 3000
ENV PORT=3000

# 注意：迁移在 Supabase 上运行，此处只启动应用
# 如需在部署时自动迁移，取消下面的注释
# CMD ["sh", "-c", "npx prisma migrate deploy && node server.js"]
CMD ["node", "server.js"]
```

### 12.3 docker-compose.yml

```yaml
# docker-compose.yml
version: "3.8"

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    restart: unless-stopped
    environment:
      NEXT_PUBLIC_SUPABASE_URL: ${NEXT_PUBLIC_SUPABASE_URL}
      NEXT_PUBLIC_SUPABASE_ANON_KEY: ${NEXT_PUBLIC_SUPABASE_ANON_KEY}
      SUPABASE_SERVICE_ROLE_KEY: ${SUPABASE_SERVICE_ROLE_KEY}
      DATABASE_URL: ${DATABASE_URL}
      DIRECT_URL: ${DIRECT_URL}
      AI_API_BASE_URL: ${AI_API_BASE_URL}
      AI_API_KEY: ${AI_API_KEY}
    ports:
      - "3000:3000"

  nginx:
    image: nginx:alpine
    restart: unless-stopped
    depends_on:
      - app
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./certs:/etc/nginx/certs:ro
```

> 对比 v1.0：去掉了 `db` 服务（PostgreSQL 容器）和 `postgres_data` 卷，服务器资源需求降低。

### 12.4 Nginx 配置（SSE 支持）

```nginx
# nginx.conf
events {
    worker_connections 1024;
}

http {
    upstream app {
        server app:3000;
    }

    server {
        listen 80;
        server_name your-domain.com;

        # HTTP → HTTPS 重定向（生产环境启用）
        # return 301 https://$server_name$request_uri;

        location / {
            proxy_pass http://app;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # SSE 专用配置 — 关键！
        location /api/chat {
            proxy_pass http://app;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # SSE 必须关闭缓冲
            proxy_buffering off;
            proxy_cache off;

            # 长连接超时（AI 响应可能较慢）
            proxy_read_timeout 300s;
            proxy_send_timeout 300s;

            # 禁用 gzip 压缩（避免缓冲 SSE 数据）
            gzip off;
        }
    }

    # HTTPS 配置（生产环境启用）
    # server {
    #     listen 443 ssl;
    #     server_name your-domain.com;
    #     ssl_certificate /etc/nginx/certs/fullchain.pem;
    #     ssl_certificate_key /etc/nginx/certs/privkey.pem;
    #     ... (同上 location 配置)
    # }
}
```

### 12.5 服务器配置建议

由于数据库不在本机，服务器配置要求较低：

| 规格 | 推荐 | 说明 |
|------|------|------|
| CPU | 1-2 核 | Next.js SSR + SSE 转发，小规模足够 |
| 内存 | 2 GB | Docker + Next.js + Nginx |
| 带宽 | 3-5 Mbps | SSE 流式传输需要稳定带宽 |
| 系统盘 | 40 GB SSD | Docker 镜像 + 日志 |

> 注意：SSE 流式代理会占用长连接。如果并发用户多，需关注服务器的连接数限制和带宽。

---

## 13. 开发阶段与里程碑

### 阶段 1：项目初始化

- [ ] 创建 Supabase 项目，获取 URL / anon key / service_role key / 数据库连接串
- [ ] 初始化 Next.js 15 项目（App Router + TypeScript）
- [ ] 配置 Tailwind CSS + shadcn/ui
- [ ] 配置 Prisma 连接 Supabase PostgreSQL（`DATABASE_URL` + `DIRECT_URL`）
- [ ] 创建数据库 Schema 并运行 `prisma migrate dev`
- [ ] 在 Supabase SQL Editor 中执行触发器脚本（用户注册 → 创建 profiles、角色同步）
- [ ] 编写并运行 seed 脚本（创建初始管理员账号）

### 阶段 2：认证系统

- [ ] 安装 `@supabase/ssr` + `@supabase/supabase-js`
- [ ] 创建服务端/客户端 Supabase Client 工具函数
- [ ] 实现注册 API（白名单校验 → Supabase Auth signUp）
- [ ] 实现登录/注册页面 UI
- [ ] 配置 Middleware 路由保护（基于 Supabase Auth session）
- [ ] 验证 JWT 中 `app_metadata.role` 可正常获取

### 阶段 3：AI 对话核心

- [ ] 实现 `/api/chat` 流式代理（Anthropic SSE 解析）
- [ ] 实现对话 CRUD API（创建/列表/详情/删除）
- [ ] 开发对话页面 UI（消息列表 + 输入框 + Markdown 渲染）
- [ ] 开发会话侧边栏（历史会话列表）
- [ ] 实现 token 用量记录
- [ ] 会话标题自动生成

### 阶段 4：管理后台

- [ ] 管理后台布局（侧边导航）
- [ ] 仪表盘页面（统计卡片 + 图表）
- [ ] 用户管理页面（列表/搜索/禁用/角色修改）
- [ ] 白名单管理页面（添加/批量/删除）
- [ ] 用量统计页面（图表 + 排行榜）
- [ ] 聊天记录查看页面
- [ ] 审计日志页面

### 阶段 5：安全加固与优化

- [ ] 请求限流（基于用户 + IP）
- [ ] 输入校验（Zod schemas）
- [ ] 每日 Token 配额限制
- [ ] 并发请求限制
- [ ] 错误处理与用户提示优化
- [ ] 加载状态与骨架屏

### 阶段 6：部署上线

- [ ] 编写 Dockerfile 与 docker-compose.yml
- [ ] 配置 Nginx（含 SSE 代理）
- [ ] 配置 HTTPS（Let's Encrypt / 自签名证书）
- [ ] Supabase 项目升级 Pro（如需要更多容量/备份）
- [ ] 监控与日志（可选接入 Sentry）
- [ ] 上线验证与联调测试

---

## 14. 技术决策备忘

### 为什么选 Next.js 全栈？

| 考虑点 | 说明 |
|--------|------|
| 前后端统一 | 一套代码库、一套部署流程，降低维护成本 |
| API Routes | 内建 Route Handlers，无需额外搭建后端服务 |
| SSE 支持 | Route Handlers 原生支持 ReadableStream，天然适合流式代理 |
| Middleware | 路由级鉴权保护，无需引入额外中间件框架 |
| 生态成熟 | Prisma、shadcn/ui、Supabase SDK 等均与 Next.js 深度集成 |
| 对比方案 | 前后端分离（React + Express）增加部署复杂度和跨域处理；Nuxt.js 生态不如 Next.js |

### 为什么选 Supabase（而非自建 PostgreSQL + Auth.js）？

| 考虑点 | 说明 |
|--------|------|
| 运维简化 | 数据库托管、自动备份、无需管理 PG 容器和数据卷 |
| 认证开箱即用 | 内置邮箱密码认证、JWT 管理、Session 刷新，代码量比 Auth.js 少 |
| 小规模友好 | 免费套餐（500MB 数据库、50K 月活用户）足够数十人使用 |
| 服务器减负 | 云服务器无需运行数据库，1-2 核 / 2GB 内存即可 |
| 保留灵活性 | 底层仍是标准 PostgreSQL，Prisma 直连，随时可迁出到自建 PG |
| 对比方案 | 自建 PG + Auth.js 需管理数据库容器、备份策略、密码加密逻辑；Clerk 功能强但费用高 |

### 为什么保留 Prisma（而非纯用 supabase-js 查询）？

| 考虑点 | 说明 |
|--------|------|
| 类型安全 | Prisma Client 自动生成 TypeScript 类型，IDE 补全和编译期校验 |
| 迁移管理 | `prisma migrate` 版本化管理 Schema 变更，可追溯 |
| 查询灵活 | 复杂聚合、关联查询比 supabase-js 的 PostgREST 更直观 |
| 可迁出 | 如未来从 Supabase 迁走，Prisma 层不用改动，只需换 `DATABASE_URL` |
| 对比方案 | 纯 supabase-js 更轻量但类型支持弱、复杂查询需拼 SQL |

---

## 15. 关键风险与应对

| # | 风险 | 影响 | 应对措施 |
|---|------|------|---------|
| 1 | **AI API 不可用或响应慢** | 用户无法使用对话功能 | 实现请求超时（300s）；前端显示友好错误提示；可选配置备用 API 端点 |
| 2 | **SSE 流中断** | 消息截断，用户体验差 | 前端检测连接中断并提示重试；后端在 `flush()` 中保存已收到的部分内容 |
| 3 | **Token 消耗失控** | API 费用超预期 | 实施每用户每日 Token 上限；仪表盘实时监控用量；异常用量告警 |
| 4 | **密钥泄露** | 安全事故 | 环境变量管理密钥；Supabase `service_role key` 不暴露前端；定期轮换 API Key |
| 5 | **Supabase 服务中断** | 数据库和认证全部不可用 | Supabase 有 99.9% SLA（Pro 套餐）；定期导出数据库备份；架构设计上 Prisma 层可快速切换到自建 PG |
| 6 | **Supabase 免费套餐超限** | 数据库暂停或降速 | 监控用量接近阈值时升级 Pro（$25/月）；定期清理过期日志数据 |
| 7 | **Nginx 缓冲 SSE** | 流式输出变成一次性输出 | `proxy_buffering off` + `gzip off`（已在 Nginx 配置中处理） |
| 8 | **网络延迟（服务器 ↔ Supabase）** | 数据库查询变慢 | 选择与 Supabase 项目同一地域的云服务器；Supabase 支持多区域 |

---

> **文档维护说明**：本文档应随项目开发进度持续更新。每个阶段完成后，勾选对应的里程碑检查项，并补充实现中遇到的问题与解决方案。
